#!/usr/bin/env ruby

############################################################################################################
# Response time and error stats based on Heroku router logs. Example usage with Heroku addon papertrail:
#
# gem install papertrail
# PAPERTRAIL_API_TOKEN=... papertrail --min-time "yesterday 22:00" --max-time "yesterday 22:30" > /tmp/papertrail.log
# gem install heroku_stats
# heroku_stats /tmp/papertrail.log
#
# To download longer timeperiods, like a whole day, download and gunzip a Papertrail log archive file.
#
# Example Heroku success log line:
#
# 768004272804798492	2017-02-14T03:41:49	2017-02-14T03:41:49Z	505641143	cmore-web-prod	54.144.85.82	Local3	Info	heroku/router	at=info method=GET path="/filmer/med/glenn-erland-tosterud" host=www.cmore.se request_id=29cb0a66-23f9-4ef4-999a-65f8de089208 fwd="216.244.66.238,23.54.19.54" dyno=web.5 connect=0ms service=210ms status=200 bytes=52867
#
# Example Heroku error log line:
#
# 768277650920906757	2017-02-14T21:48:07	2017-02-14T21:48:08Z	505641143	cmore-web-prod	54.196.126.116	Local3	Info	heroku/router	at=error code=H12 desc="Request timeout" method=GET path="/serie/74763-alvinnn-og-gjengen-tv-serien/sesong-1/episode-2/3282212-alvinnn-og-gjengen-tv-serien-forelsket-i-rektor-norsk-tale" host=www.cmore.no request_id=f5c2921a-3974-4522-8fdf-d9bfff8b1db9 fwd="163.172.66.89,80.239.216.108" dyno=web.5 connect=0ms service=30001ms status=503 bytes=0
#
# Resources:
#
# Heroku Logging: https://devcenter.heroku.com/articles/logging
# Heroku Error Codes: https://devcenter.heroku.com/articles/error-codes
# Papertrail archives: https://papertrailapp.com/account/archives
# Papertrail archive download: http://help.papertrailapp.com/kb/how-it-works/permanent-log-archives/#downloading-multiple-archives
#
############################################################################################################

FIELDS = [
  {name: :method},
  {name: :host},
  {name: :path},
  {name: :status, numeric: true},
  {name: :code, optional: true},
  {name: :service, numeric: true}
]
TOP_LIST_LIMIT = 100
PAPERTRAIL_LINE = /\sheroku\/router:?\s/ # NOTE: Papertrails log format differs slightly from Herokus
HEROKU_LINE = /\sheroku\[router\]:\s/
APDEX = {tolerating: 500, frustrated: 2000}
APDEX_GOAL = 0.9

def strip_quotes(value)
  if value && value.start_with?('"')
    value[1..-2]
  else
    value
  end
end

def parse_numeric(value)
  value[/\d+/].to_i
end

def parse_field(field, line_string)
  value = /\b#{field[:name]}=(\S+)/.match(line_string).to_a[1]
  puts "Parsing failed field=#{field} line=#{line_string}" unless (value || field[:optional])
  value = strip_quotes(value)
  value = parse_numeric(value) if field[:numeric]
  value
rescue Exception => e
  puts "Parsing failed field=#{field} line=#{line_string}: #{e.message}"
  nil
end

def parse_time(line_string)
  line_string[/\b20\d\d-\d\d-\d\dT\d\d:\d\d:\d\d/]
end

def parse_line(line_string)
  FIELDS.reduce({}) do |acc, field|
    if value = parse_field(field, line_string)
      acc[field[:name]] = value
    end
    acc
  end
end

def print_line(line)
  parts = [(line[:method] == "GET" ? nil : line[:method]),
            line[:path],
            line[:service],
            line[:code]
          ].compact
  if parts.size > 1
    puts parts.join(" ")
  end
end

def router_line?(line_string)
  line_string =~ PAPERTRAIL_LINE || line_string =~ HEROKU_LINE
end

def error_status?(status)
  status / 100 == 5
end

def lines_by_duration(lines)
  lines.sort_by { |line| -line[:service].to_i }
end

def line_stats(lines)
  lines.reduce({}) do |acc, line|
    id = (line[:method] == "GET" ? '' : "#{line[:method]} ") + [line[:host], line[:path]].join('')
    acc[id] ||= {
      id: id,
      method: line[:method],
      path: line[:path],
      count: 0,
      success_count: 0,
      error_count: 0,
      timeout_count: 0,
      code_count: Hash.new(0),
      satisfied_count: 0,
      tolerating_count: 0,
      frustrated_count: 0,
      service: 0
    }
    acc[id][:count] += 1
    if error_status?(line[:status])
      acc[id][:error_count] += 1
      acc[id][:frustrated_count] += 1
    else
      acc[id][:success_count] += 1
      if line[:service] <= APDEX[:tolerating]
        acc[id][:satisfied_count] += 1
      elsif line[:service] <= APDEX[:frustrated]
        acc[id][:tolerating_count] += 1
      else
        acc[id][:frustrated_count] += 1
      end
    end
    if line[:code]
      acc[id][:code_count][line[:code]] += 1
    end
    if line[:code] == "H12"
      acc[id][:timeout_count] += 1
    end
    acc[id][:service] += line[:service]
    acc
  end.values
end

def duration_metric(stat)
  stat[:service].to_f/stat[:count]
end

def error_rate_metric(stat)
  stat[:error_count].to_f/stat[:count]
end

def timeout_metric(stat)
  stat[:timeout_count]
end

def popularity_metric(stat)
  stat[:count]
end

def apdex_metric(stat)
  (stat[:satisfied_count] + stat[:tolerating_count].to_f/2)/stat[:count]
end

def stats_by_metric(stats, metric, direction = 1)
  stats.sort do |stat1, stat2|
    metric1 = -1 * direction * metric.call(stat1)
    metric2 = -1 * direction * metric.call(stat2)
    if metric1 == metric2
      0
    elsif metric1.nil? || metric2.nil?
      metric1.nil? ? -1 : 1
    else
      metric1 > metric2 ? 1 : -1
    end
  end
end

def print_percentages(total_lines_count, grouped_lines)
  grouped_lines.select { |key, _| !key.nil? }.each do |key, lines|
    percent = (lines.size.to_f*100/total_lines_count).round(4)
    puts "#{key} #{percent}%"
  end
end

def print_top_list(stats, metric, direction = 1)
  stats_by_metric(stats, metric, direction)[0, TOP_LIST_LIMIT].each do |stat|
    apdex = apdex_metric(stat).round(2)
    puts [stat[:id],
          metric.call(stat),
          "count=#{stat[:count]}",
          "apdex=#{apdex}",
          (apdex >= APDEX_GOAL ? "OK" : "SLOW")
         ].join(' ')
  end
end

def print_heading(heading)
  puts "\n-----------------------------------------------------------"
  puts heading
  puts "-----------------------------------------------------------\n\n"
end

module KPI
  PRECISION = 5

  def self.calculate(lines, stats)
    {
      request_count: lines.size,
      response_time_avg: avg(:service, lines),
      response_time_95p: percentile(:service, 0.95, lines),
      apdex: avg(method(:apdex_metric), stats),
      error_rate: rate(method(:error?), lines),
      timeout_rate: rate(method(:timeout?), lines)
    }
  end

  def self.rate(predicate, lines)
    (count(predicate, lines).to_f/lines.size).round(PRECISION)
  end

  def self.count(predicate, lines)
    lines.select(&predicate).size
  end

  def self.avg(metric, lines)
    sum = lines.reduce(0) do |acc, line|
      value = metric.respond_to?(:call) ? metric.call(line) : line[metric]
      acc + value
    end
    (sum/lines.size.to_f).round(PRECISION)
  end

  def self.percentile(field, percentile, lines)
    index = (lines.size*percentile).round - 1
    line = lines.sort_by { |line| line[field] }[index]
    line && line[field]
  end

  def self.error?(line)
    error_status?(line[:status])
  end

  def self.timeout?(line)
    line[:code] == "H12"
  end

  def self.print(kpi)
    kpi.each do |key, value|
      puts "#{key}: #{value}"
    end
  end
end

log_file_data = ARGF.read

line_strings = log_file_data.split("\n").select(&method(:router_line?))
lines_count = line_strings.size
puts "\nNumber of router lines: #{lines_count}"
puts "Start time: #{parse_time(line_strings[0])}"
puts "End time: #{parse_time(line_strings[-1])}"

puts "\nParsing router lines..."
lines = line_strings.map(&method(:parse_line))

puts "Calculating stats..."
stats = line_stats(lines)
lines_by_status = lines.group_by { |line| line[:status] }
lines_by_code = lines.group_by { |line| line[:code] }
kpi = KPI.calculate(lines, stats)

print_heading("KPIs")
KPI.print(kpi)

print_heading("STATUS CODES")
print_percentages(lines_count, lines_by_status)

print_heading("HEROKU ERROR CODES")
print_percentages(lines_count, lines_by_code)

print_heading("POPULARITY TOP LIST")
print_top_list(stats, method(:popularity_metric))

print_heading("APDEX TOP LIST")
print_top_list(stats, method(:apdex_metric), -1)

print_heading("DURATION TOP LIST")
print_top_list(stats, method(:duration_metric))

print_heading("ERROR RATE TOP LIST")
print_top_list(stats, method(:error_rate_metric))

print_heading("TIMEOUT TOP LIST")
print_top_list(stats, method(:timeout_metric))

lines_by_status.each do |status, lines|
  print_heading("REQUESTS - STATUS #{status}")
  lines_by_duration(lines).each do |line|
    print_line(line)
  end
end
